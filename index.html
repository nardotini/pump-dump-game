<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>🎰 Pump or Dump</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #0f0f23 !important;
            color: white !important;
            overflow-x: hidden;
            height: 100vh;
            position: fixed;
            width: 100%;
            top: 0;
            left: 0;
        }

        body {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%) !important;
        }

        .webapp-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            background: transparent;
        }

        /* Compact Header - Minimal height */
        .header {
            background: rgba(0, 0, 0, 0.9) !important;
            backdrop-filter: blur(20px);
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 100;
            min-height: 50px;
        }

        .header h1 {
            font-size: 1.2em;
            font-weight: 800;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9em;
        }

        .timer-header {
            font-size: 1.4em;
            font-weight: 900;
            color: #ff4757 !important;
            text-shadow: 0 0 10px rgba(255, 71, 87, 0.8);
        }

        .balance {
            background: rgba(255, 215, 0, 0.2) !important;
            padding: 3px 8px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            font-weight: bold;
            color: #ffd700 !important;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .balance:hover {
            background: rgba(255, 215, 0, 0.3) !important;
            transform: scale(1.05);
        }

        /* Wallet Menu */
        .wallet-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            z-index: 1000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .wallet-content {
            background: rgba(15, 15, 35, 0.9);
            border: 2px solid rgba(78, 205, 196, 0.3);
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 100%;
            text-align: center;
        }

        .wallet-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 20px;
        }

        .wallet-balance {
            font-size: 2em;
            font-weight: 900;
            color: #4ecdc4;
            margin-bottom: 30px;
        }

        .wallet-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .wallet-btn {
            padding: 15px;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .wallet-btn.withdraw {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        }

        .wallet-btn:hover {
            transform: scale(1.05);
        }

        .close-wallet {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            cursor: pointer;
        }

        /* Game Area - Maximum space for chart */
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 8px;
            gap: 8px;
            overflow-y: auto;
            background: transparent;
        }

        /* Minimal Round Status */
        .round-status {
            background: rgba(0, 0, 0, 0.3) !important;
            border-radius: 12px;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 40px;
        }

        .round-number {
            font-size: 0.9em;
            color: #ffd700 !important;
            font-weight: bold;
        }

        .phase-indicator {
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 4px 8px;
            border-radius: 8px;
            color: white !important;
        }

        .phase-betting {
            background: linear-gradient(135deg, #4ecdc4, #44a08d) !important;
        }

        .phase-revealing {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24) !important;
        }

        /* Win/Loss Result Overlay */
        .result-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 500;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .result-content {
            background: rgba(15, 15, 35, 0.9);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            border: 3px solid;
            max-width: 350px;
            width: 100%;
        }

        .result-content.win {
            border-color: #4ecdc4;
            box-shadow: 0 0 30px rgba(78, 205, 196, 0.5);
        }

        .result-content.loss {
            border-color: #ff6b6b;
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
        }

        .result-title {
            font-size: 2em;
            font-weight: 900;
            margin-bottom: 10px;
        }

        .result-title.win {
            color: #4ecdc4;
        }

        .result-title.loss {
            color: #ff6b6b;
        }

        .result-amount {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffd700;
        }

        .result-message {
            font-size: 1em;
            margin-bottom: 20px;
            opacity: 0.9;
        }

        .result-close {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }

        /* Leaderboard Section */
        .leaderboard-section {
            background: rgba(0, 0, 0, 0.4) !important;
            border-radius: 12px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 8px;
        }

        .leaderboard-title {
            text-align: center;
            font-size: 0.9em;
            color: #ffd700 !important;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .leaderboard-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .leaderboard-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 6px 8px;
            border-radius: 8px;
            border-left: 3px solid;
            font-size: 0.75em;
        }

        .leaderboard-item.round {
            border-left-color: #4ecdc4;
        }

        .leaderboard-item.daily {
            border-left-color: #ffd700;
        }

        .leaderboard-label {
            opacity: 0.8;
            margin-bottom: 2px;
        }

        .leaderboard-value {
            font-weight: bold;
            color: white;
        }

        /* MASSIVE CHART SECTION - This is the star! */
        .chart-section {
            background: rgba(0, 0, 0, 0.7) !important;
            border-radius: 15px;
            padding: 10px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(78, 205, 196, 0.3);
            position: relative;
            
            /* HUGE HEIGHT - Takes up most of the screen */
            height: calc(100vh - 320px);
            min-height: 300px;
            max-height: 450px;
            
            overflow: hidden;
            margin: 5px 0;
        }

        .chart-wrapper {
            position: relative;
            height: 100%;
            width: 100%;
            z-index: 2;
            background: transparent;
        }

        /* Enhanced chart visibility */
        #priceChart {
            background: transparent !important;
            filter: brightness(1.3) contrast(1.3) saturate(1.2);
            width: 100% !important;
            height: 100% !important;
        }

        .chart-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }

        .chart-result {
            font-size: 4em;
            font-weight: 900;
            text-shadow: 0 0 40px currentColor;
            animation: resultExplosion 2s ease-out;
        }

        .chart-result.pump {
            color: #4ecdc4 !important;
        }

        .chart-result.dump {
            color: #ff6b6b !important;
        }

        @keyframes resultExplosion {
            0% {
                transform: scale(0) rotate(-180deg);
                opacity: 0;
            }
            30% {
                transform: scale(1.3) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        /* Compact user bet status */
        .user-bet-status {
            background: rgba(255, 215, 0, 0.15) !important;
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 6px 10px;
            text-align: center;
            margin: 4px 0;
            font-size: 0.8em;
            color: white !important;
        }

        .user-bet-status.hidden {
            display: none;
        }

        /* Compact Pot Display */
        .pot-section {
            background: rgba(0, 0, 0, 0.4) !important;
            border-radius: 12px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .pot-title {
            text-align: center;
            font-size: 1em;
            color: #ffd700 !important;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .pot-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .pot-item {
            text-align: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3) !important;
            border-radius: 10px;
            border: 2px solid transparent;
            color: white !important;
        }

        .pot-item.pump {
            border-color: #4ecdc4 !important;
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1)) !important;
        }

        .pot-item.dump {
            border-color: #ff6b6b !important;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 107, 107, 0.1)) !important;
        }

        .pot-emoji {
            font-size: 1.2em;
            margin-bottom: 2px;
        }

        .pot-amount {
            font-size: 1em;
            font-weight: bold;
            margin-bottom: 2px;
            color: white !important;
        }

        .pot-percentage {
            font-size: 0.7em;
            opacity: 0.9;
            background: rgba(255, 255, 255, 0.2) !important;
            padding: 1px 4px;
            border-radius: 6px;
            color: white !important;
        }

        .total-info {
            text-align: center;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8em;
            color: white !important;
        }

        /* Compact Bet Controls */
        .bet-controls {
            background: rgba(0, 0, 0, 0.4) !important;
            border-radius: 12px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bet-amount-selector {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .amount-btn {
            padding: 4px 6px;
            background: rgba(0, 0, 0, 0.4) !important;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white !important;
            font-size: 0.7em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            min-width: 32px;
        }

        .amount-btn.active {
            background: #ffd700 !important;
            color: #000 !important;
            border-color: #ffd700;
            font-weight: bold;
        }

        .custom-amount-section {
            display: flex;
            gap: 6px;
            margin: 6px 0;
            align-items: center;
            justify-content: center;
        }

        .custom-amount-input {
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.4) !important;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white !important;
            font-size: 0.75em;
            width: 100px;
            text-align: center;
        }

        .custom-amount-input::placeholder {
            color: rgba(255, 255, 255, 0.5) !important;
        }

        .custom-amount-btn {
            padding: 4px 8px;
            background: rgba(255, 215, 0, 0.2) !important;
            border: 1px solid rgba(255, 215, 0, 0.4);
            border-radius: 8px;
            color: #ffd700 !important;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        /* Compact Betting Buttons */
        .betting-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .bet-button {
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-size: 1em;
            font-weight: bold;
            color: white !important;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            border: 2px solid transparent;
        }

        .bet-button.pump {
            background: linear-gradient(135deg, #4ecdc4, #44a08d) !important;
            border-color: #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
        }

        .bet-button.dump {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24) !important;
            border-color: #ff6b6b;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.3);
        }

        .bet-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .bet-button:active {
            transform: scale(0.95);
        }

        /* Minimal Recent Results */
        .results-section {
            background: rgba(0, 0, 0, 0.4) !important;
            border-radius: 12px;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .results-title {
            text-align: center;
            font-size: 0.9em;
            color: #ffd700 !important;
            margin-bottom: 6px;
            font-weight: bold;
        }

        .results-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 80px;
            overflow-y: auto;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.3) !important;
            border-radius: 6px;
            font-size: 0.7em;
            border-left: 2px solid transparent;
            color: white !important;
        }

        .result-item.pump {
            border-left-color: #4ecdc4;
        }

        .result-item.dump {
            border-left-color: #ff6b6b;
        }

        .loading {
            text-align: center;
            padding: 8px;
            opacity: 0.8;
            font-size: 0.8em;
            color: white !important;
        }

        /* Haptic feedback */
        .haptic-success {
            animation: successPulse 0.3s ease-out;
        }

        @keyframes successPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Mobile optimizations */
        @media (max-width: 480px) {
            .header {
                padding: 6px 10px;
                min-height: 45px;
            }
            
            .header h1 {
                font-size: 1.1em;
            }
            
            .timer-header {
                font-size: 1.2em;
            }
            
            .game-area {
                padding: 6px;
                gap: 6px;
            }
            
            .chart-section {
                height: calc(100vh - 300px);
                min-height: 280px;
                padding: 8px;
            }
            
            .chart-result {
                font-size: 3em;
            }
        }

        /* Floating particles */
        .floating-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 0;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.4), transparent);
            border-radius: 50%;
            animation: particleFloat 10s infinite linear;
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-10vh) translateX(50px) rotate(360deg);
                opacity: 0;
            }
        }

        /* NEW: Instant transition animations */
        .round-transition {
            animation: newRoundFlash 0.5s ease-out;
        }

        @keyframes newRoundFlash {
            0% { background-color: rgba(78, 205, 196, 0.3); }
            100% { background-color: transparent; }
        }
    </style>
</head>
<body>
    <div class="floating-particles" id="particles"></div>
    
    <div class="webapp-container">
        <!-- Compact Header -->
        <div class="header">
            <h1>🎰 Pump or Dump</h1>
            <div class="header-right">
                <div class="timer-header" id="timer">15s</div>
                <div class="balance" id="userBalance" onclick="openWallet()">10.000 SOL</div>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area">
            <!-- Minimal Round Status -->
            <div class="round-status">
                <div class="round-number" id="roundNumber">Round #1</div>
                <div class="phase-indicator phase-betting" id="phaseIndicator">🎯 Betting</div>
            </div>

            <!-- NEW: Leaderboard Section -->
            <div class="leaderboard-section">
                <div class="leaderboard-title">🏆 Leaderboard</div>
                <div class="leaderboard-stats">
                    <div class="leaderboard-item round">
                        <div class="leaderboard-label">🔥 Round Winner</div>
                        <div class="leaderboard-value" id="roundWinner">-</div>
                    </div>
                    <div class="leaderboard-item daily">
                        <div class="leaderboard-label">👑 Daily Best</div>
                        <div class="leaderboard-value" id="dailyWinner">25.7x CryptoKing</div>
                    </div>
                </div>
            </div>

            <!-- MASSIVE CHART SECTION - THE STAR OF THE SHOW -->
            <div class="chart-section">
                <div class="chart-overlay" id="chartOverlay" style="display: none;">
                    <div class="chart-result" id="chartResult"></div>
                </div>
                <div class="chart-wrapper">
                    <canvas id="priceChart"></canvas>
                </div>
            </div>

            <!-- Compact User Bet Status -->
            <div class="user-bet-status hidden" id="userBetStatus">
                <strong id="userBetDisplay">-</strong> 🍀
            </div>

            <!-- Compact Pot Display -->
            <div class="pot-section">
                <div class="pot-title">💰 Live Pot</div>
                <div class="pot-display">
                    <div class="pot-item pump">
                        <div class="pot-emoji">📈</div>
                        <div class="pot-amount" id="pumpAmount">0.000</div>
                        <div class="pot-percentage" id="pumpPercent">0%</div>
                    </div>
                    <div class="pot-item dump">
                        <div class="pot-emoji">📉</div>
                        <div class="pot-amount" id="dumpAmount">0.000</div>
                        <div class="pot-percentage" id="dumpPercent">0%</div>
                    </div>
                </div>
                <div class="total-info">
                    <span>👥 <span id="playerCount">0</span> Players</span>
                    <span>💎 <span id="totalPot">0.000</span> SOL</span>
                </div>
            </div>

            <!-- Compact Betting Controls -->
            <div class="bet-controls">
                <!-- Bet Amount Selector -->
                <div class="bet-amount-selector">
                    <div class="amount-btn" data-amount="0.01">0.01</div>
                    <div class="amount-btn" data-amount="0.05">0.05</div>
                    <div class="amount-btn active" data-amount="0.1">0.1</div>
                    <div class="amount-btn" data-amount="0.2">0.2</div>
                    <div class="amount-btn" data-amount="0.5">0.5</div>
                    <div class="amount-btn" data-amount="1.0">1.0</div>
                    <div class="amount-btn" data-amount="2.0">2.0</div>
                </div>
                
                <!-- Custom Amount -->
                <div class="custom-amount-section">
                    <input type="number" id="customAmount" placeholder="Custom" min="0.01" max="10" step="0.01" class="custom-amount-input">
                    <button class="custom-amount-btn" id="useCustomAmount">Use</button>
                </div>

                <!-- Betting Buttons -->
                <div class="betting-section">
                    <button class="bet-button pump" id="pumpButton" data-type="PUMP">
                        📈 PUMP
                    </button>
                    <button class="bet-button dump" id="dumpButton" data-type="DUMP">
                        📉 DUMP
                    </button>
                </div>
            </div>

            <!-- Minimal Recent Results -->
            <div class="results-section">
                <div class="results-title">📊 Recent</div>
                <div class="results-list" id="resultsList">
                    <div class="loading">Loading...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Win/Loss Result Overlay -->
    <div class="result-overlay" id="resultOverlay">
        <div class="result-content" id="resultContent">
            <div class="result-title" id="resultTitle">🎉 YOU WON!</div>
            <div class="result-amount" id="resultAmount">+2.5 SOL</div>
            <div class="result-message" id="resultMessage">Awesome prediction! 🚀</div>
            <button class="result-close" onclick="closeResult()">Continue Playing</button>
        </div>
    </div>

    <!-- NEW: Wallet Menu -->
    <div class="wallet-menu" id="walletMenu">
        <div class="wallet-content">
            <div class="wallet-title">💰 Your Wallet</div>
            <div class="wallet-balance" id="walletBalance">10.000 SOL</div>
            <div class="wallet-buttons">
                <button class="wallet-btn" onclick="depositMoney()">
                    💎 Deposit
                </button>
                <button class="wallet-btn withdraw" onclick="withdrawMoney()">
                    💸 Withdraw
                </button>
            </div>
            <button class="close-wallet" onclick="closeWallet()">Close</button>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <!-- Solana Web3.js -->
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>

    <script>
        console.log('🎰 Real Money Pump or Dump Starting...');

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCm8L54hCLrR36T6eV3KAOD_8iHGyv-AJs",
            authDomain: "pump-dump-game.firebaseapp.com",
            databaseURL: "https://pump-dump-game-default-rtdb.firebaseio.com",
            projectId: "pump-dump-game",
            storageBucket: "pump-dump-game.firebasestorage.app",
            messagingSenderId: "455371839436",
            appId: "1:455371839436:web:6be0e809019f82f3322f69"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        // User state
        let currentUser = null;
        let userWallet = null;
        let gameStateListener = null;
        let currentRoundListener = null;

        // Telegram Web App Integration
        const tg = window.Telegram?.WebApp;
        let userData = null;
        let gameState = {
            round: 1,
            phase: 'betting',
            timeLeft: 15,
            pumpPot: 0,
            dumpPot: 0,
            playerCount: 0,
            userBalance: 10.0,
            userBet: null,
            selectedAmount: 0.1,
            recentResults: [],
            currentResult: null,
            roundWinner: null,
            dailyBest: { multiplier: 25.7, name: 'CryptoKing' },
            // NEW: Real-time multiplayer data
            activePlayers: {},
            roundBets: { pump: {}, dump: {} }
        };

        // Initialize Telegram Web App + Firebase
        function initTelegramWebApp() {
            if (tg) {
                tg.ready();
                tg.expand();
                tg.disableVerticalSwipes();
                
                if (tg.setBackgroundColor) {
                    tg.setBackgroundColor('#0f0f23');
                }
                if (tg.setHeaderColor) {
                    tg.setHeaderColor('#000000');
                }
                
                userData = tg.initDataUnsafe?.user;
                if (userData) {
                    console.log('👤 User:', userData.first_name);
                }
                
                console.log('✅ Telegram Web App initialized');
            } else {
                console.log('⚠️ Running outside Telegram - demo mode');
                userData = { first_name: 'Demo User', id: 12345 };
            }

            // Initialize Firebase Authentication
            initFirebaseAuth();
        }

        // Firebase Authentication
        function initFirebaseAuth() {
            auth.signInAnonymously()
                .then((userCredential) => {
                    currentUser = userCredential.user;
                    console.log('🔐 User authenticated:', currentUser.uid);
                    loadUserBalance();
                })
                .catch((error) => {
                    console.error('❌ Auth error:', error);
                    // Fallback to demo mode
                    console.log('⚠️ Using demo mode');
                });
        }

        // Load user balance from Firebase
        async function loadUserBalance() {
            if (!currentUser) return;

            try {
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    gameState.userBalance = userData.balance || 10.0;
                    userWallet = userData.wallet || null;
                    console.log('💰 Loaded balance:', gameState.userBalance);
                } else {
                    // New user - create with 10 SOL starting balance
                    await db.collection('users').doc(currentUser.uid).set({
                        balance: 10.0,
                        wallet: null,
                        created: firebase.firestore.FieldValue.serverTimestamp(),
                        totalWagered: 0,
                        totalWon: 0
                    });
                    gameState.userBalance = 10.0;
                    console.log('🎉 New user created with 10 SOL!');
                }
                
                // Load global round number
                await loadGlobalRound();
                
                updateDisplay();
            } catch (error) {
                console.error('❌ Error loading balance:', error);
            }
        }

        // Load user balance from Firebase
        async function loadUserBalance() {
            if (!currentUser) return;

            try {
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    gameState.userBalance = userData.balance || 10.0;
                    userWallet = userData.wallet || null;
                    console.log('💰 Loaded balance:', gameState.userBalance);
                } else {
                    // New user - create with 10 SOL starting balance
                    const userName = userData?.first_name || userData?.username || 'Player';
                    await db.collection('users').doc(currentUser.uid).set({
                        balance: 10.0,
                        wallet: null,
                        name: userName,
                        created: firebase.firestore.FieldValue.serverTimestamp(),
                        totalWagered: 0,
                        totalWon: 0
                    });
                    gameState.userBalance = 10.0;
                    console.log('🎉 New user created with 10 SOL!');
                }
                
                // Start real-time game sync
                startRealtimeSync();
                
                updateDisplay();
            } catch (error) {
                console.error('❌ Error loading balance:', error);
            }
        }

        // START REAL-TIME MULTIPLAYER SYNC
        function startRealtimeSync() {
            console.log('🌍 Starting real-time multiplayer sync...');
            
            // Listen to global game state
            gameStateListener = db.collection('game').doc('current')
                .onSnapshot((doc) => {
                    if (doc.exists) {
                        const data = doc.data();
                        
                        // Update game state from server
                        gameState.round = data.round || 1;
                        gameState.phase = data.phase || 'betting';
                        gameState.timeLeft = data.timeLeft || 15;
                        
                        // Calculate time since last update for accurate countdown
                        if (data.lastUpdate) {
                            const serverTime = data.lastUpdate.toMillis();
                            const now = Date.now();
                            const elapsed = Math.floor((now - serverTime) / 1000);
                            gameState.timeLeft = Math.max(0, gameState.timeLeft - elapsed);
                        }
                        
                        console.log(`🎯 Synced: Round ${gameState.round}, Phase: ${gameState.phase}, Time: ${gameState.timeLeft}s`);
                        updateDisplay();
                    }
                });
            
            // Listen to current round bets
            listenToCurrentRound();
        }

        // Listen to current round data
        function listenToCurrentRound() {
            if (currentRoundListener) {
                currentRoundListener();
            }
            
            currentRoundListener = db.collection('rounds').doc(`round_${gameState.round}`)
                .onSnapshot((doc) => {
                    if (doc.exists) {
                        const data = doc.data();
                        gameState.roundBets = data.bets || { pump: {}, dump: {} };
                        gameState.activePlayers = data.players || {};
                        
                        // Calculate pots from real bets
                        gameState.pumpPot = Object.values(gameState.roundBets.pump || {})
                            .reduce((sum, bet) => sum + bet.amount, 0);
                        gameState.dumpPot = Object.values(gameState.roundBets.dump || {})
                            .reduce((sum, bet) => sum + bet.amount, 0);
                        gameState.playerCount = Object.keys({...gameState.roundBets.pump, ...gameState.roundBets.dump}).length;
                        
                        // Check if user has bet
                        const userPumpBet = gameState.roundBets.pump[currentUser?.uid];
                        const userDumpBet = gameState.roundBets.dump[currentUser?.uid];
                        
                        if (userPumpBet) {
                            gameState.userBet = { type: 'PUMP', amount: userPumpBet.amount };
                        } else if (userDumpBet) {
                            gameState.userBet = { type: 'DUMP', amount: userDumpBet.amount };
                        } else {
                            gameState.userBet = null;
                        }
                        
                        console.log(`💰 Live pots: PUMP ${gameState.pumpPot.toFixed(3)}, DUMP ${gameState.dumpPot.toFixed(3)}`);
                        updateDisplay();
                    }
                });
        }

        // Load global round number and start as game master if needed
        async function loadGlobalRound() {
            try {
                const gameDoc = await db.collection('game').doc('current').get();
                
                if (gameDoc.exists) {
                    const gameData = gameDoc.data();
                    gameState.round = gameData.round || 1;
                    console.log('🎯 Loaded global round:', gameState.round);
                } else {
                    // Initialize global round and become game master
                    await initializeGameMaster();
                }
            } catch (error) {
                console.error('❌ Error loading round:', error);
                gameState.round = 1;
            }
        }

        // Initialize as game master (first player)
        async function initializeGameMaster() {
            console.log('👑 Becoming game master...');
            
            await db.collection('game').doc('current').set({
                round: 1,
                phase: 'betting',
                timeLeft: 15,
                lastUpdate: firebase.firestore.FieldValue.serverTimestamp(),
                gameMaster: currentUser.uid
            });
            
            gameState.round = 1;
            gameState.phase = 'betting';
            gameState.timeLeft = 15;
            
            // Start game master loop
            startGameMasterLoop();
            
            console.log('👑 Game master initialized!');
        }

        // Game master controls the global timer
        function startGameMasterLoop() {
            setInterval(async () => {
                if (gameState.timeLeft > 0) {
                    gameState.timeLeft--;
                } else {
                    if (gameState.phase === 'betting') {
                        // Start revealing phase
                        gameState.phase = 'revealing';
                        gameState.timeLeft = 5;
                        
                        // Generate result and save to current round
                        const result = Math.random() > 0.48 ? 'PUMP' : 'DUMP';
                        await saveRoundResult(result);
                        
                    } else if (gameState.phase === 'revealing') {
                        // Start next round
                        gameState.round++;
                        gameState.phase = 'betting';
                        gameState.timeLeft = 15;
                        
                        // Update leaderboard and start new round
                        await updateLeaderboard();
                        await initializeNewRound();
                        
                        // Listen to new round
                        listenToCurrentRound();
                    }
                }
                
                // Update global game state
                await updateGlobalGameState();
                
            }, 1000);
        }

        // Update global game state in Firebase
        async function updateGlobalGameState() {
            try {
                await db.collection('game').doc('current').update({
                    round: gameState.round,
                    phase: gameState.phase,
                    timeLeft: gameState.timeLeft,
                    lastUpdate: firebase.firestore.FieldValue.serverTimestamp()
                });
            } catch (error) {
                console.error('❌ Error updating game state:', error);
            }
        }

        // Save round result and process winners
        async function saveRoundResult(result) {
            try {
                const roundRef = db.collection('rounds').doc(`round_${gameState.round}`);
                const roundDoc = await roundRef.get();
                
                if (roundDoc.exists) {
                    const roundData = roundDoc.data();
                    const winners = result === 'PUMP' ? roundData.bets.pump : roundData.bets.dump;
                    const totalPot = gameState.pumpPot + gameState.dumpPot;
                    const houseCut = totalPot * 0.05;
                    const winnersPool = totalPot - houseCut;
                    const winningPot = result === 'PUMP' ? gameState.pumpPot : gameState.dumpPot;
                    const multiplier = winningPot > 0 ? winnersPool / winningPot : 0;
                    
                    // Update round with result
                    await roundRef.update({
                        result: result,
                        winners: Object.keys(winners),
                        multiplier: multiplier,
                        totalPot: totalPot,
                        completed: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    // Update winner balances
                    for (const [userId, bet] of Object.entries(winners)) {
                        const payout = bet.amount * multiplier;
                        await db.collection('users').doc(userId).update({
                            balance: firebase.firestore.FieldValue.increment(payout - bet.amount)
                        });
                    }
                    
                    console.log(`🎊 Round ${gameState.round} complete: ${result}, ${multiplier.toFixed(2)}x`);
                }
            } catch (error) {
                console.error('❌ Error saving round result:', error);
            }
        }

        // Initialize new round
        async function initializeNewRound() {
            try {
                await db.collection('rounds').doc(`round_${gameState.round}`).set({
                    round: gameState.round,
                    bets: { pump: {}, dump: {} },
                    players: {},
                    created: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                console.log(`🎯 New round ${gameState.round} initialized`);
            } catch (error) {
                console.error('❌ Error initializing round:', error);
            }
        }

        // Update leaderboard with round winners
        async function updateLeaderboard() {
            try {
                // Get completed round data
                const roundDoc = await db.collection('rounds').doc(`round_${gameState.round}`).get();
                
                if (roundDoc.exists) {
                    const data = roundDoc.data();
                    
                    if (data.winners && data.winners.length > 0 && data.multiplier > 1) {
                        // Find biggest winner
                        let biggestWinner = null;
                        let biggestWinAmount = 0;
                        
                        for (const userId of data.winners) {
                            const betData = data.result === 'PUMP' ? data.bets.pump[userId] : data.bets.dump[userId];
                            if (betData) {
                                const winAmount = betData.amount * data.multiplier;
                                if (winAmount > biggestWinAmount) {
                                    biggestWinAmount = winAmount;
                                    biggestWinner = { userId, name: betData.name, multiplier: data.multiplier };
                                }
                            }
                        }
                        
                        if (biggestWinner) {
                            gameState.roundWinner = `${biggestWinner.multiplier.toFixed(1)}x ${biggestWinner.name}`;
                            
                            // Update daily best if higher
                            if (biggestWinner.multiplier > gameState.dailyBest.multiplier) {
                                gameState.dailyBest = { 
                                    multiplier: biggestWinner.multiplier, 
                                    name: biggestWinner.name 
                                };
                                
                                // Save to Firebase
                                await db.collection('leaderboard').doc('daily').set({
                                    multiplier: biggestWinner.multiplier,
                                    name: biggestWinner.name,
                                    userId: biggestWinner.userId,
                                    round: gameState.round,
                                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                                });
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('❌ Error updating leaderboard:', error);
            }
        }

        // Save user balance to Firebase
        async function saveUserBalance() {
            if (!currentUser) return;

            try {
                await db.collection('users').doc(currentUser.uid).update({
                    balance: gameState.userBalance,
                    lastPlayed: firebase.firestore.FieldValue.serverTimestamp()
                });
                console.log('💾 Balance saved:', gameState.userBalance);
            } catch (error) {
                console.error('❌ Error saving balance:', error);
            }
        }

        // Wallet functions
        function openWallet() {
            document.getElementById('walletMenu').style.display = 'flex';
            document.getElementById('walletBalance').textContent = `${gameState.userBalance.toFixed(3)} SOL`;
            
            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('light');
            }
        }

        function closeWallet() {
            document.getElementById('walletMenu').style.display = 'none';
        }

        function depositMoney() {
            // Show deposit modal with Solana wallet integration
            if (tg?.showPopup) {
                tg.showPopup({
                    title: '💎 Deposit SOL',
                    message: `Send SOL to this address:\n\n7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgHkv\n\nMinimum: 0.1 SOL\nBalance updates automatically!`,
                    buttons: [
                        {id: 'copy', type: 'default', text: '📋 Copy Address'},
                        {id: 'close', type: 'cancel', text: 'Close'}
                    ]
                }, (buttonId) => {
                    if (buttonId === 'copy') {
                        // Copy wallet address to clipboard
                        navigator.clipboard?.writeText('7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgHkv');
                        tg.showAlert('✅ Wallet address copied!');
                    }
                });
            } else {
                // Fallback for non-Telegram
                const address = '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgHkv';
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(address);
                    alert(`💎 Deposit Address Copied!\n\n${address}\n\nSend SOL to this address.\nMinimum: 0.1 SOL`);
                } else {
                    alert(`💎 Deposit SOL to:\n\n${address}\n\nMinimum: 0.1 SOL\nBalance updates automatically!`);
                }
            }
        }

        function withdrawMoney() {
            if (gameState.userBalance < 0.1) {
                if (tg?.showAlert) {
                    tg.showAlert('💸 Minimum withdrawal is 0.1 SOL. Keep playing to win more!');
                } else {
                    alert('💸 Minimum withdrawal is 0.1 SOL. Keep playing to win more!');
                }
                return;
            }
            
            // Show withdrawal form
            if (tg?.showPopup) {
                tg.showPopup({
                    title: '💰 Withdraw SOL',
                    message: `Available: ${gameState.userBalance.toFixed(3)} SOL\n\nEnter your Solana wallet address to withdraw.\n\nFee: 0.01 SOL\nProcessing: Instant`,
                    buttons: [
                        {id: 'withdraw', type: 'default', text: '💸 Enter Address'},
                        {id: 'close', type: 'cancel', text: 'Cancel'}
                    ]
                }, (buttonId) => {
                    if (buttonId === 'withdraw') {
                        // In real implementation, show input form
                        tg.showAlert('🚧 Withdrawal form coming soon! You\'ll be able to enter your wallet address and withdraw instantly.');
                    }
                });
            } else {
                // Fallback for non-Telegram
                const address = prompt('💰 Enter your Solana wallet address:');
                if (address && address.length > 30) {
                    alert(`✅ Withdrawal initiated!\n\nAmount: ${(gameState.userBalance - 0.01).toFixed(3)} SOL\nTo: ${address.substring(0, 20)}...\nFee: 0.01 SOL\n\n🚧 Feature coming soon!`);
                } else if (address) {
                    alert('❌ Invalid wallet address. Please enter a valid Solana address.');
                }
            }
        }

        // Win/Loss result functions
        function showResultOverlay(won, amount, multiplier) {
            const overlay = document.getElementById('resultOverlay');
            const content = document.getElementById('resultContent');
            const title = document.getElementById('resultTitle');
            const amountEl = document.getElementById('resultAmount');
            const message = document.getElementById('resultMessage');
            
            content.className = `result-content ${won ? 'win' : 'loss'}`;
            title.className = `result-title ${won ? 'win' : 'loss'}`;
            
            if (won) {
                title.textContent = '🎉 YOU WON!';
                amountEl.textContent = `+${amount.toFixed(3)} SOL`;
                
                const messages = [
                    'Incredible prediction! 🚀',
                    'You nailed it! 💎',
                    'Amazing call! 🔥',
                    'Perfect timing! ⚡',
                    'You\'re on fire! 🎯'
                ];
                message.textContent = messages[Math.floor(Math.random() * messages.length)];
                
                if (multiplier > 3) {
                    message.textContent += ` ${multiplier.toFixed(1)}x multiplier!`;
                }
            } else {
                title.textContent = '💔 So Close!';
                amountEl.textContent = `-${gameState.userBet.amount.toFixed(3)} SOL`;
                
                const messages = [
                    'Try again! You got this! 💪',
                    'Almost had it! Next round! 🎯',
                    'So close! Keep going! 🚀',
                    'Better luck next time! 🍀',
                    'You\'ll get the next one! ⚡'
                ];
                message.textContent = messages[Math.floor(Math.random() * messages.length)];
            }
            
            overlay.style.display = 'flex';
            
            if (tg?.HapticFeedback) {
                if (won) {
                    tg.HapticFeedback.notificationOccurred('success');
                } else {
                    tg.HapticFeedback.notificationOccurred('error');
                }
            }
        }

        function closeResult() {
            document.getElementById('resultOverlay').style.display = 'none';
        }

        // Enhanced Chart with FIXED result sync
        const ctx = document.getElementById('priceChart').getContext('2d');
        let chart;
        let chartStartValue = 100;
        let chartEndValue = 100;

        function initChart() {
            try {
                const data = generateChartData();
                chartStartValue = data.values[0];
                chartEndValue = data.values[data.values.length - 1];
                
                chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.labels,
                        datasets: [{
                            label: 'Price',
                            data: data.values,
                            borderColor: '#4ecdc4',
                            backgroundColor: 'rgba(78, 205, 196, 0.2)',
                            borderWidth: 5,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 10,
                            pointBackgroundColor: '#4ecdc4',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { 
                            legend: { display: false }
                        },
                        scales: { 
                            x: { 
                                display: false,
                                grid: { display: false }
                            }, 
                            y: { 
                                display: false,
                                grid: { display: false }
                            }
                        },
                        elements: {
                            point: { radius: 0 }
                        },
                        animation: { duration: 0 }
                    }
                });
                
                console.log('📊 Chart initialized with FIXED sync');
                return true;
            } catch (error) {
                console.error('❌ Chart error:', error);
                return false;
            }
        }

        function generateChartData() {
            const labels = [];
            const values = [];
            let currentPrice = 80 + Math.random() * 40; // Start between 80-120
            
            for (let i = 0; i < 60; i++) {
                labels.push(i);
                const change = (Math.random() - 0.5) * 6;
                currentPrice += change;
                currentPrice = Math.max(40, Math.min(160, currentPrice));
                values.push(currentPrice);
            }
            
            return { labels, values };
        }

        function moveChart() {
            if (!chart || gameState.phase !== 'betting') return;
            
            try {
                const currentData = [...chart.data.datasets[0].data];
                const lastValue = currentData[currentData.length - 1];
                const change = (Math.random() - 0.5) * 8;
                const newValue = Math.max(20, Math.min(180, lastValue + change));
                
                currentData.shift();
                currentData.push(newValue);
                
                chart.data.datasets[0].data = currentData;
                chartEndValue = newValue; // Track the current end value
                
                // Update colors based on movement
                if (newValue > lastValue) {
                    chart.data.datasets[0].borderColor = '#4ecdc4';
                    chart.data.datasets[0].backgroundColor = 'rgba(78, 205, 196, 0.25)';
                } else {
                    chart.data.datasets[0].borderColor = '#ff6b6b';
                    chart.data.datasets[0].backgroundColor = 'rgba(255, 107, 107, 0.25)';
                }
                
                chart.update('none');
            } catch (error) {
                console.error('Chart movement error:', error);
            }
        }

        function animateChart(finalResult) {
            if (!chart) return;
            
            // OPTION B: Realistic Movement Constraints for fairness
            const startData = [...chart.data.datasets[0].data];
            const initialValue = startData[Math.floor(startData.length * 0.6)];
            const currentTrend = startData[startData.length - 1] - startData[startData.length - 10];
            
            let step = 0;
            const totalSteps = 10;
            let finalValue;
            
            // REALISTIC CONSTRAINTS: Check if result makes sense with current trend
            const trendStrength = Math.abs(currentTrend);
            const isGoingUp = currentTrend > 0;
            const isGoingDown = currentTrend < 0;
            
            // If strong trend exists, respect it more often for realism
            let actualResult = finalResult;
            if (trendStrength > 15) { // Strong trend detected
                if (isGoingUp && finalResult === 'DUMP' && Math.random() < 0.3) {
                    // 30% chance to override unrealistic DUMP when strongly trending up
                    actualResult = 'PUMP';
                    console.log('🎯 Realistic override: Strong uptrend, switched to PUMP');
                } else if (isGoingDown && finalResult === 'PUMP' && Math.random() < 0.3) {
                    // 30% chance to override unrealistic PUMP when strongly trending down
                    actualResult = 'DUMP';
                    console.log('🎯 Realistic override: Strong downtrend, switched to DUMP');
                }
            }
            
            // Set realistic target based on actual result and current trend
            if (actualResult === 'PUMP') {
                if (isGoingUp) {
                    // Continue the uptrend naturally
                    finalValue = initialValue + 20 + Math.random() * 30;
                } else {
                    // Reverse downtrend (more dramatic but realistic)
                    finalValue = initialValue + 15 + Math.random() * 25;
                }
            } else {
                if (isGoingDown) {
                    // Continue the downtrend naturally
                    finalValue = initialValue - 20 - Math.random() * 30;
                } else {
                    // Reverse uptrend (more dramatic but realistic)
                    finalValue = initialValue - 15 - Math.random() * 25;
                }
            }
            
            const interval = setInterval(() => {
                try {
                    const progress = step / totalSteps;
                    const newData = [...startData];
                    
                    for (let i = Math.floor(startData.length * 0.6); i < startData.length; i++) {
                        const baseValue = startData[i];
                        const progressToFinal = (i - Math.floor(startData.length * 0.6)) / (startData.length - Math.floor(startData.length * 0.6));
                        const targetValue = baseValue + (finalValue - baseValue) * progressToFinal;
                        
                        // REALISTIC VOLATILITY: Less jarring movements
                        let volatility;
                        if (progress > 0.8) {
                            // Final 20% - minimal volatility for clear result
                            volatility = (Math.random() - 0.5) * 4;
                        } else if (progress > 0.5) {
                            // Middle phase - moderate volatility
                            volatility = (Math.random() - 0.5) * 12 * (1 - progress * 0.5);
                        } else {
                            // Early phase - normal volatility
                            volatility = (Math.random() - 0.5) * 16 * (1 - progress * 0.3);
                        }
                        
                        // SMOOTH REALISTIC MOVEMENT: More natural acceleration
                        const smoothMovement = baseValue + (targetValue - baseValue) * Math.pow(progress, 0.7);
                        
                        newData[i] = Math.max(10, Math.min(190, smoothMovement + volatility));
                    }
                    
                    chart.data.datasets[0].data = newData;
                    
                    // Set colors to match actual result (more pronounced in final steps)
                    if (actualResult === 'PUMP') {
                        chart.data.datasets[0].borderColor = progress > 0.7 ? '#4ecdc4' : '#4ecdc4';
                        chart.data.datasets[0].backgroundColor = `rgba(78, 205, 196, ${0.2 + progress * 0.3})`;
                    } else {
                        chart.data.datasets[0].borderColor = progress > 0.7 ? '#ff6b6b' : '#ff6b6b';
                        chart.data.datasets[0].backgroundColor = `rgba(255, 107, 107, ${0.2 + progress * 0.3})`;
                    }
                    
                    chart.data.datasets[0].borderWidth = 6 + (progress * 2);
                    chart.update('none');
                    step++;
                    
                    if (step >= totalSteps) {
                        clearInterval(interval);
                        showResult(actualResult); // Show the actual (possibly adjusted) result
                        
                        // Store actual result for syncing
                        gameState.currentResult = actualResult;
                        chartEndValue = newData[newData.length - 1];
                    }
                } catch (error) {
                    clearInterval(interval);
                }
            }, 50);
        }

        function showResult(result) {
            const overlay = document.getElementById('chartOverlay');
            const resultElement = document.getElementById('chartResult');
            
            resultElement.textContent = result === 'PUMP' ? '📈 PUMP!' : '📉 DUMP!';
            resultElement.className = `chart-result ${result.toLowerCase()}`;
            
            overlay.style.display = 'block';
            
            // Show result for 1.5 seconds (faster)
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 1500);
        }

        // Game logic
        function updateDisplay() {
            document.getElementById('roundNumber').textContent = `Round #${gameState.round}`;
            document.getElementById('timer').textContent = `${gameState.timeLeft}s`;
            document.getElementById('userBalance').textContent = `${gameState.userBalance.toFixed(3)} SOL`;
            
            const total = gameState.pumpPot + gameState.dumpPot;
            const pumpPercent = total > 0 ? ((gameState.pumpPot / total) * 100).toFixed(1) : 0;
            const dumpPercent = total > 0 ? ((gameState.dumpPot / total) * 100).toFixed(1) : 0;
            
            document.getElementById('pumpAmount').textContent = gameState.pumpPot.toFixed(3);
            document.getElementById('dumpAmount').textContent = gameState.dumpPot.toFixed(3);
            document.getElementById('pumpPercent').textContent = `${pumpPercent}%`;
            document.getElementById('dumpPercent').textContent = `${dumpPercent}%`;
            document.getElementById('playerCount').textContent = gameState.playerCount;
            document.getElementById('totalPot').textContent = total.toFixed(3);
            
            const phaseIndicator = document.getElementById('phaseIndicator');
            phaseIndicator.className = `phase-indicator phase-${gameState.phase}`;
            
            switch(gameState.phase) {
                case 'betting':
                    phaseIndicator.textContent = '🎯 Betting';
                    break;
                case 'revealing':
                    phaseIndicator.textContent = '🎲 Revealing';
                    break;
            }
            
            const canBet = gameState.phase === 'betting' && gameState.timeLeft > 0 && !gameState.userBet;
            document.getElementById('pumpButton').disabled = !canBet;
            document.getElementById('dumpButton').disabled = !canBet;
            
            const betStatus = document.getElementById('userBetStatus');
            const betDisplay = document.getElementById('userBetDisplay');
            
            if (gameState.userBet) {
                betStatus.classList.remove('hidden');
                betDisplay.textContent = `${gameState.userBet.type} ${gameState.userBet.amount} SOL`;
            } else {
                betStatus.classList.add('hidden');
            }

            // Update leaderboard
            document.getElementById('roundWinner').textContent = gameState.roundWinner || '-';
            document.getElementById('dailyWinner').textContent = `${gameState.dailyBest.multiplier}x ${gameState.dailyBest.name}`;
        }

        function updateRecentResults() {
            const container = document.getElementById('resultsList');
            container.innerHTML = '';
            
            if (gameState.recentResults.length === 0) {
                container.innerHTML = '<div class="loading">No results yet...</div>';
                return;
            }
            
            gameState.recentResults.slice(0, 5).forEach(result => {
                const div = document.createElement('div');
                div.className = `result-item ${result.result.toLowerCase()}`;
                div.innerHTML = `
                    <span>#${result.round}</span>
                    <span>${result.result === 'PUMP' ? '📈' : '📉'}</span>
                    <span>${result.pot}</span>
                `;
                container.appendChild(div);
            });
        }

        function placeBet(type) {
            if (gameState.phase !== 'betting' || gameState.timeLeft <= 0 || gameState.userBet) {
                return;
            }
            
            if (gameState.userBalance < gameState.selectedAmount) {
                if (tg?.showAlert) {
                    tg.showAlert(`Need ${gameState.selectedAmount} SOL!`);
                } else {
                    alert(`Need ${gameState.selectedAmount} SOL!`);
                }
                return;
            }
            
            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('medium');
            }
            
            // Place bet in Firebase
            placeBetInFirebase(type, gameState.selectedAmount);
            
            const button = document.getElementById(type.toLowerCase() + 'Button');
            button.classList.add('haptic-success');
            setTimeout(() => button.classList.remove('haptic-success'), 300);
            
            console.log(`💰 Bet placed: ${type} ${gameState.selectedAmount} SOL`);
        }

        // Place bet in Firebase (real-time multiplayer)
        async function placeBetInFirebase(type, amount) {
            try {
                const userName = userData?.first_name || userData?.username || 'Player';
                const roundRef = db.collection('rounds').doc(`round_${gameState.round}`);
                
                // Add bet to Firebase
                const betPath = type === 'PUMP' ? 'bets.pump' : 'bets.dump';
                await roundRef.set({
                    [`${betPath}.${currentUser.uid}`]: {
                        amount: amount,
                        name: userName,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    },
                    [`players.${currentUser.uid}`]: {
                        name: userName,
                        lastBet: firebase.firestore.FieldValue.serverTimestamp()
                    }
                }, { merge: true });
                
                // Update user balance
                gameState.userBalance -= amount;
                await saveUserBalance();
                
                console.log(`🌍 Multiplayer bet placed: ${type} ${amount} SOL`);
                
            } catch (error) {
                console.error('❌ Error placing bet:', error);
            }
        }

        // Create subtle particles
        function createParticles() {
            const container = document.getElementById('particles');
            
            setInterval(() => {
                if (Math.random() < 0.2) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = Math.random() * 100 + 'vw';
                    particle.style.animationDelay = Math.random() * 3 + 's';
                    particle.style.animationDuration = (8 + Math.random() * 4) + 's';
                    
                    container.appendChild(particle);
                    
                    setTimeout(() => {
                        particle.remove();
                    }, 15000);
                }
            }, 300);
        }

        // Round transition animation
        function showRoundTransition() {
            const roundStatus = document.querySelector('.round-status');
            roundStatus.classList.add('round-transition');
            setTimeout(() => {
                roundStatus.classList.remove('round-transition');
            }, 500);
        }

        // ENHANCED: Game simulation with results tracking
        function simulateGame() {
            setInterval(() => {
                if (gameState.timeLeft > 0) {
                    gameState.timeLeft--;
                } else {
                    if (gameState.phase === 'betting') {
                        // Start revealing phase - 5 seconds for lightning fast reveals!
                        gameState.phase = 'revealing';
                        gameState.timeLeft = 5;
                        
                        // Generate result (slightly favor PUMP for excitement)
                        const result = Math.random() > 0.48 ? 'PUMP' : 'DUMP';
                        animateChart(result);
                        
                        // Calculate and show user result
                        if (gameState.userBet) {
                            const won = gameState.userBet.type === result;
                            if (won) {
                                const winningPot = result === 'PUMP' ? gameState.pumpPot : gameState.dumpPot;
                                const totalPot = gameState.pumpPot + gameState.dumpPot;
                                const houseCut = totalPot * 0.05;
                                const winnersPool = totalPot - houseCut;
                                const multiplier = winningPot > 0 ? winnersPool / winningPot : 1;
                                const payout = gameState.userBet.amount * multiplier;
                                
                                gameState.userBalance += payout;
                                
                                // Save balance to Firebase
                                saveUserBalance();
                                
                                // Show win overlay after 1.5 seconds (faster timing)
                                setTimeout(() => {
                                    showResultOverlay(true, payout, multiplier);
                                }, 1500);
                                
                            } else {
                                // Show loss overlay after 1.5 seconds (faster timing)
                                setTimeout(() => {
                                    showResultOverlay(false, gameState.userBet.amount, 0);
                                }, 1500);
                            }
                        }
                        
                    } else if (gameState.phase === 'revealing') {
                        // INSTANT TRANSITION to next round
                        gameState.round++;
                        gameState.phase = 'betting';
                        gameState.timeLeft = 15; // OPTIMIZED: 15s betting rounds
                        
                        // Save global round number
                        saveGlobalRound();
                        
                        // Use the stored result for consistency
                        const result = gameState.currentResult || (Math.random() > 0.5 ? 'PUMP' : 'DUMP');
                        
                        // Calculate round winner
                        const totalPot = gameState.pumpPot + gameState.dumpPot;
                        if (totalPot > 0) {
                            const winningPot = result === 'PUMP' ? gameState.pumpPot : gameState.dumpPot;
                            const multiplier = winningPot > 0 ? (totalPot * 0.95) / winningPot : 0;
                            
                            if (multiplier > 1) {
                                gameState.roundWinner = `${multiplier.toFixed(1)}x Someone`;
                                
                                // Update daily best if this is higher
                                if (multiplier > gameState.dailyBest.multiplier) {
                                    gameState.dailyBest = { multiplier: multiplier, name: 'Someone' };
                                }
                            }
                        }
                        
                        // Add result to history
                        gameState.recentResults.unshift({
                            round: gameState.round - 1,
                            result: result,
                            pot: totalPot.toFixed(2)
                        });
                        
                        
                        // Reset for new round
                        gameState.pumpPot = 0;
                        gameState.dumpPot = 0;
                        gameState.playerCount = 0;
                        gameState.userBet = null;
                        gameState.currentResult = null;
                        
                        // Update displays
                        updateRecentResults();
                        showRoundTransition();
                        
                        // Generate new chart
                        if (chart) {
                            const newData = generateChartData();
                            chart.data.datasets[0].data = newData.values;
                            chart.data.datasets[0].borderColor = '#4ecdc4';
                            chart.data.datasets[0].backgroundColor = 'rgba(78, 205, 196, 0.2)';
                            chart.data.datasets[0].borderWidth = 5;
                            chart.update();
                        }
                        
                        console.log('🚀 INSTANT ROUND TRANSITION with Firebase persistence!');
                    }
                }
                
                // Simulate other players betting during betting phase
                if (gameState.phase === 'betting' && Math.random() < 0.5) {
                    const betAmount = 0.05 + Math.random() * 2;
                    if (Math.random() > 0.5) {
                        gameState.pumpPot += betAmount;
                    } else {
                        gameState.dumpPot += betAmount;
                    }
                    gameState.playerCount = Math.max(gameState.playerCount, Math.floor(Math.random() * 25) + 1);
                }
                
                updateDisplay();
            }, 1000);
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            initTelegramWebApp();
            
            if (initChart()) {
                console.log('✅ Real Money game with Firebase ready');
                
                // Amount selection buttons
                document.querySelectorAll('.amount-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.amount-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        gameState.selectedAmount = parseFloat(btn.dataset.amount);
                        
                        document.getElementById('customAmount').value = '';
                        
                        if (tg?.HapticFeedback) {
                            tg.HapticFeedback.impactOccurred('light');
                        }
                    });
                });
                
                // Custom amount functionality
                document.getElementById('useCustomAmount').addEventListener('click', () => {
                    const customInput = document.getElementById('customAmount');
                    const customValue = parseFloat(customInput.value);
                    
                    if (customValue && customValue >= 0.01 && customValue <= 10) {
                        document.querySelectorAll('.amount-btn').forEach(b => b.classList.remove('active'));
                        gameState.selectedAmount = customValue;
                        
                        document.getElementById('useCustomAmount').style.background = 'rgba(78, 205, 196, 0.3)';
                        setTimeout(() => {
                            document.getElementById('useCustomAmount').style.background = 'rgba(255, 215, 0, 0.2)';
                        }, 300);
                        
                        if (tg?.HapticFeedback) {
                            tg.HapticFeedback.impactOccurred('medium');
                        }
                        
                        console.log(`Custom amount set: ${customValue} SOL`);
                    } else {
                        if (tg?.showAlert) {
                            tg.showAlert('Enter 0.01 to 10 SOL');
                        } else {
                            alert('Enter 0.01 to 10 SOL');
                        }
                    }
                });
                
                document.getElementById('pumpButton').addEventListener('click', () => placeBet('PUMP'));
                document.getElementById('dumpButton').addEventListener('click', () => placeBet('DUMP'));
                
                setTimeout(() => {
                    // Don't start old simulation - using real-time sync now!
                    // simulateGame(); // REMOVED
                    updateDisplay();
                    createParticles();
                    
                    setInterval(() => {
                        if (gameState.phase === 'betting') {
                            moveChart();
                        }
                    }, 600);
                    
                }, 1000);
                
                console.log('🚀 REAL-TIME MULTIPLAYER game ready!');
            }
            }
        });
    </script>
</body>
</html>
